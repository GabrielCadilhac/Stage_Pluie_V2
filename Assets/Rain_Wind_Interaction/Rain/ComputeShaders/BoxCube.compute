// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define SIZE 1024

// ====== Struct ======
struct OBB
{
    float3 center;
    float3 size;
    float4x4 rotation;
};

// ====== Buffers ======
RWStructuredBuffer<float3> Velocities;
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float> Sizes;
RWStructuredBuffer<float3> SplashPos;
RWStructuredBuffer<float3> SplashNormal;
RWStructuredBuffer<OBB> Obbs;

// ====== Settings ======
const uint _NumParticles;
const uint _NumObbs;
const uint _Resolution;

const float3 _Min;
const float3 _Max;
const float3 _InitialVel;
const float3 _GlobalWind;

//Generateur de nombre aleatoire
float hash12(float2 p_p)
{
    float3 p3 = frac(float3(p_p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

uint2 pcg2d(uint2 v)
{
    v = v * 1664525u + 1013904223u;

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v >> 16u);

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v >> 16u);

    return v;
}

// Retourne un nombre aleatoire entre p_Min et p_Max
float range12_hash(float2 p_p, float p_Min, float p_Max)
{
    float r = hash12(p_p);
    return p_Min * (1.0 - r) + p_Max * r;
}

float range12(uint2 p_p, float p_Min, float p_Max)
{
    uint2 r = pcg2d(p_p);
    float rand = float(r.x) * float(r.y);
    return p_Min * (1.0 - rand) + p_Max * rand;
}

// Mise a jour de la vitesse et de la position
void changePosVel(uint3 p_id, float3 p_newPos)
{
    Positions[p_id.x] = p_newPos;
    float3 Vmax = float3(0., -9.65 + 10.3 * exp(-0.6 * Sizes[p_id.x]), 0.);
    
    float varPerc = 1.2;
    float randX = _GlobalWind.x + range12_hash(p_id.xz, -_GlobalWind.x * varPerc, _GlobalWind.x * varPerc);
    float randY = range12_hash(p_id.xz, Vmax.y, Vmax.y * varPerc);
    float randZ = _GlobalWind.z + range12_hash(p_id.xz, -_GlobalWind.z * varPerc, _GlobalWind.z * varPerc);
    
    //Velocities[p_id.x] = _InitialVel + float3(randX, randY, randZ);
    Velocities[p_id.x] = Vmax + float3(randX, randY, randZ);
    
}

// Function to get the column of a matrix
float3 GetColumn(float4x4 p_matrix, int p_id)
{
    return float3(p_matrix[0][p_id], p_matrix[1][p_id], p_matrix[2][p_id]);
}

// Return the index of the OBB collided
int OBBCollision(float3 p_pos)
{
    for (uint i = 0; i < _NumObbs; i++)
    {
        OBB obb = Obbs[i];
        
        float3 D = p_pos - obb.center;
        float3 ux = normalize(GetColumn(obb.rotation, 0));
        float3 uy = normalize(GetColumn(obb.rotation, 1));
        float3 uz = normalize(GetColumn(obb.rotation, 2));
        
        float px = dot(D, ux);
        float py = dot(D, uy);
        float pz = dot(D, uz);
        
        if (abs(px) <= obb.size.x && abs(py) <= obb.size.y && abs(pz) <= obb.size.z)
            return i;
    }
    return -1;
}

float3 CollisionPoint(float3 p_pos, int p_boxId)
{
    OBB obb = Obbs[p_boxId];
    
    float3 D = p_pos - obb.center;
    float3 ux = normalize(GetColumn(obb.rotation, 0));
    float3 uy = normalize(GetColumn(obb.rotation, 1));
    float3 uz = normalize(GetColumn(obb.rotation, 2));
    
    float px = dot(D, ux);
    float py = dot(D, uy);
    float pz = dot(D, uz);
        
    float dx = abs(px) - obb.size.x;
    float dy = abs(py) - obb.size.y;
    float dz = abs(pz) - obb.size.z;
    
    if (dx > dy && dx > dz)
        return obb.center + sign(px) * (obb.size.x + 0.001) * ux + py * uy + pz * uz;
    else if (dy > dz)
        return obb.center + px * ux + sign(py) * (obb.size.y + 0.001) * uy + pz * uz;
    return obb.center + px * ux + py * uy + sign(pz) * (obb.size.z + 0.001) * uz;
}

float3 ComputeNormal(float3 p_pos, int p_boxId)
{
    OBB obb = Obbs[p_boxId];
        
    float3 D = p_pos - obb.center;
    float3 ux = normalize(GetColumn(obb.rotation, 0));
    float3 uy = normalize(GetColumn(obb.rotation, 1));
    float3 uz = normalize(GetColumn(obb.rotation, 2));
        
    float px = dot(D, ux);
    float py = dot(D, uy);
    float pz = dot(D, uz);
    
    float dx = abs(px) - obb.size.x;
    float dy = abs(py) - obb.size.y;
    float dz = abs(pz) - obb.size.z;
    
    if (dx > dy && dx > dz)
        return ux * sign(px);
    else if (dy > dz)
        return uy * sign(py);
    return uz * sign(pz);
}

[numthreads(SIZE,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    while (id.x < _NumParticles)
    {   
        int i = OBBCollision(Positions[id.x]);
        if (i != -1) // Collision detected
        {
            SplashPos[id.x] = CollisionPoint(Positions[id.x], i);
            SplashNormal[id.x] = ComputeNormal(Positions[id.x], i);
            
            changePosVel(id, float3(Positions[id.x].x, _Max.y, Positions[id.x].z));
        }
        // Check collision with rain box
        else if (Positions[id.x].y < _Min.y) // Collision with the bottom of the rain box
        {
            // Add splatch on particle collided rain box
            SplashPos[id.x]  = float3(Positions[id.x].x, _Min.y, Positions[id.x].z);
            SplashNormal[id.x] = float3(0., 1., 0.);
            
            float dist = Positions[id.x].y - _Min.y;
            changePosVel(id, float3(Positions[id.x].x, _Max.y + dist, Positions[id.x].z));
        }
        else if (Positions[id.x].x < _Min.x)
        {
            float dist = _Min.x - Positions[id.x].x;
            changePosVel(id, float3(_Max.x - dist, Positions[id.x].y, Positions[id.x].z));
        }
        else if (Positions[id.x].x > _Max.x)
        {
            float dist = Positions[id.x].x - _Max.x;
            changePosVel(id, float3(_Min.x + dist, Positions[id.x].y, Positions[id.x].z));
        }
        else if (Positions[id.x].z < _Min.z)
        {
            float dist = Positions[id.x].z - _Min.z;
            changePosVel(id, float3(Positions[id.x].x, Positions[id.x].y, _Max.z - dist));
        }
        else if (Positions[id.x].z > _Max.z)
        {
            float dist = Positions[id.x].z - _Max.z;
            changePosVel(id, float3(Positions[id.x].x, Positions[id.x].y, _Min.z + dist));
        }
        id.x += SIZE * _Resolution;
    }
}
