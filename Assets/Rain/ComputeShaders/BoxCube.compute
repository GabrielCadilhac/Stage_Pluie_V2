// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define SIZE 1024

// ====== Buffers ======
RWStructuredBuffer<float3> Velocities;
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float3> SplashPos;
RWStructuredBuffer<float> SplashTime;

// ====== Settings ======
const uint _NumParticles;
const uint _Resolution;

const float3 _Min;
const float3 _Max;
const float3 _InitialVel;
const float3 _GlobalWind;

//Generateur de nombre aleatoire
float hash12(float2 p_p)
{
    float3 p3 = frac(float3(p_p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

uint2 pcg2d(uint2 v)
{
    v = v * 1664525u + 1013904223u;

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v >> 16u);

    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;

    v = v ^ (v >> 16u);

    return v;
}

// Retourne un nombre aleatoire entre p_Min et p_Max
float range12_hash(float2 p_p, float p_Min, float p_Max)
{
    float r = hash12(p_p);
    return p_Min * (1.0 - r) + p_Max * r;
}

float range12(uint2 p_p, float p_Min, float p_Max)
{
    uint2 r = pcg2d(p_p);
    float rand = float(r.x) * float(r.y);
    return p_Min * (1.0 - rand) + p_Max * rand;
}

// Mise a jour de la vitesse et de la position
void changePosVel(uint3 p_id, float3 p_newPos)
{
    float3 globalWind = _GlobalWind;
    Positions[p_id.x] = p_newPos;
    
    float varPerc = 1.;
    float randX = globalWind.x + range12_hash(p_id.xz, -globalWind.x * varPerc, globalWind.x * varPerc);
    float randY = range12_hash(p_id.xz, _InitialVel.y, _InitialVel.y + 1.0);
    float randZ = globalWind.z + range12_hash(p_id.xz, -globalWind.z * varPerc, globalWind.z * varPerc);
    
    Velocities[p_id.x] = _InitialVel + float3(randX, randY, randZ);
}

[numthreads(SIZE,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    while (id.x < _NumParticles)
    {
        // Splash
        SplashTime[id.x] -= 0.015;
        SplashTime[id.x] = SplashTime[id.x] < 0. ? 0. : SplashTime[id.x];
        
        // Verifier les collisions avec les bords de la boite
        if (Positions[id.x].y < _Min.y) // Collision avec le sol de la boite
        {
            // Dessiner un splash sur le ground
            SplashPos[id.x]  = float3(Positions[id.x].x, _Min.y, Positions[id.x].z);
            SplashTime[id.x] = 1.0;
            
            float dist = Positions[id.x].y - _Min.y;
            changePosVel(id, float3(Positions[id.x].x, _Max.y + dist, Positions[id.x].z));
        }
        else if (Positions[id.x].x < _Min.x)
        {
            float dist = _Min.x - Positions[id.x].x;
            changePosVel(id, float3(_Max.x - dist, Positions[id.x].y, Positions[id.x].z));
        }
        else if (Positions[id.x].x > _Max.x)
        {
            float dist = Positions[id.x].x - _Max.x;
            changePosVel(id, float3(_Min.x + dist, Positions[id.x].y, Positions[id.x].z));
        }
        else if (Positions[id.x].z < _Min.z)
        {
            float dist = Positions[id.x].z - _Min.z;
            changePosVel(id, float3(Positions[id.x].x, Positions[id.x].y, _Max.z - dist));
        }
        else if (Positions[id.x].z > _Max.z)
        {
            float dist = Positions[id.x].z - _Max.z;
            changePosVel(id, float3(Positions[id.x].x, Positions[id.x].y, _Min.z + dist));
        }
        id.x += SIZE * _Resolution;
    }
}
