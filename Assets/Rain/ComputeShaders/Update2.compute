// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define SIZE 1024
#define PI 3.1415

struct Primitive
{
    int type;
    float3 position;
    float param;
};

// ====== Buffers ======
RWStructuredBuffer<float3> Velocities;
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<Primitive> Primitives;

// ====== Settings ======
const uint _NumParticles = 0;
const uint _Resolution = 0;

const float _DeltaTime = 0.;
const float _DropsCX = 0.;
const float _DropDiam = 0.;
const float _LocalWindForce = 0.;

const float4x4 _WorldToLocal;

const float3 _Gravity = float3(0.0, -9.81, 0.0);
const float3 _GlobalWind = float3(0., 0., 0.);

float3 CartToCyl(float3 coord)
{
    float r = sqrt(coord.x * coord.x + coord.y * coord.y);
    float theta = 0.;
    if (coord.x != 0.)
        theta = atan(coord.y / coord.x);
    else if (coord.y > 0.)
        theta = PI / 2.;
    else if (coord.y < 0.)
        theta = -PI / 2.;
    
    if (coord.x < 0.)
        theta += PI;
    
    return float3(r, theta, coord.z);
}

float2 CylToCart(float2 coord)
{
    return float2(coord.x * cos(coord.y), coord.x * sin(coord.y));
}

float3 GetValue(float3 partPos, Primitive prim)
{
    float4 tempPos = mul(_WorldToLocal, float4(prim.position, 1.));
    const float3 localPos = tempPos.xyz / tempPos.w;
    
    const float3 vect = abs(localPos - partPos);
    float size = 20.;
    
    if (length(vect) > size)
        return float3(0., 0., 0.);
    
    if (prim.type == 0) // Uniform
    {
        const float3 direction = float3(prim.param, 0., 0.);
        return mul(float3(size, 0., 0.) - vect, direction);
    }
    
    float3 cylCoord = CartToCyl(vect);
    
    if (prim.type == 1) // Source
        cylCoord.x = prim.param / (2. * PI * size);
    else // Vortex
        cylCoord.y = prim.param / (2. * PI * size);        
    
    return float3(cylCoord.x * cos(cylCoord.y), cylCoord.x * sin(cylCoord.y), -cylCoord.z);
}

float3 ComputeWind(float3 pos)
{
	uint numStructs = 0;
	uint stride = 0;
    Primitives.GetDimensions(numStructs, stride);
        
    float3 totalWind = _GlobalWind * length(_GlobalWind);
    
    for (uint i = 0; i < numStructs; i++)
    {
	    const float3 w = GetValue(pos, Primitives[i]);
        totalWind += w * length(w) * _LocalWindForce;
    }
    
    return totalWind;
}

[numthreads(SIZE, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    while (id.x < _NumParticles)
    {
        float3 wind = ComputeWind(Positions[id.x]);
        //float acceleration = _Gravity + (0.9195 * _DropsCX / _DropDiam) * (wind * length(wind) - Velocities[id.x] * length(Velocities[id.x]);
        float3 acceleration = _Gravity + (0.9195 * _DropsCX / _DropDiam) * wind;
        Velocities[id.x] += acceleration * _DeltaTime;
        Positions[id.x]  += Velocities[id.x] * _DeltaTime;
        
        id.x += SIZE * _Resolution;
    }
}
